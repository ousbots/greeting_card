use bevy::input::touch::Touches;
use bevy::prelude::*;

use crate::interaction::{Highlight, Interactable, aabb_overlap};

// Click component for click feedback sprite.
#[derive(Component)]
struct Click;

// Timer to track click indicator fade.
#[derive(Component)]
struct ClickFade(Timer);

// Input positions from cursor and touch input.
#[derive(Resource, Default)]
struct InputWorldPositions {
    positions: Vec<Vec2>,
}

// Input directions.
#[derive(Component, Clone, Copy, Debug, Eq, PartialEq)]
pub enum Direction {
    Left,
    Right,
    Up,
}

// Input events generated by the user.
#[derive(Debug, Default, Message)]
pub struct InputEvent {
    pub direction: Option<Direction>,
    pub target: Option<InputTarget>,
}

#[derive(Clone, Copy, Debug)]
pub struct InputTarget {
    pub x: f32,
    pub action: bool,
}

// Cursor size for aabb detection.
const CURSOR_SIZE: f32 = 0.1;

// Initialize input systems.
pub fn add_systems(app: &mut App) {
    app.init_resource::<InputWorldPositions>().add_systems(
        Update,
        (
            handle_fade,
            handle_keys,
            handle_mouse_input,
            handle_touch_input,
            update_input_positions.before(detect_hover),
            detect_hover,
        ),
    );
}

// Process a world-space click/tap and emit appropriate events.
fn process_world_click(
    commands: &mut Commands,
    world_pos: Vec2,
    interactables: &Query<(&GlobalTransform, &Interactable)>,
    input_events: &mut MessageWriter<InputEvent>,
) {
    let action: bool = interactables.iter().any(|(transform, interactable)| {
        aabb_overlap(
            world_pos,
            CURSOR_SIZE,
            CURSOR_SIZE,
            transform.translation().truncate(),
            interactable.width,
            interactable.height,
        )
    });

    input_events.write(InputEvent {
        target: Some(InputTarget {
            x: world_pos.x,
            action: action,
        }),
        ..default()
    });

    commands.spawn((
        Sprite {
            color: Color::srgba(1.0, 1.0, 0.0, 0.8),
            custom_size: Some(Vec2::splat(3.0)),
            ..default()
        },
        Transform::from_translation(Vec3::new(world_pos.x, world_pos.y, 10.0)),
        Click,
        ClickFade(Timer::from_seconds(1.0, TimerMode::Once)),
    ));
}

// Fade marker alpha over time
fn handle_fade(
    mut commands: Commands,
    time: Res<Time>,
    mut query: Query<(Entity, &mut Sprite, &mut ClickFade), With<Click>>,
) {
    for (entity, mut sprite, mut fade) in &mut query {
        fade.0.tick(time.delta());

        // Calculate fade progress (0.0 to 1.0)
        let progress = fade.0.elapsed_secs() / fade.0.duration().as_secs_f32();

        // Fade from 0.8 to 0.0 alpha
        let alpha = 0.8 * (1.0 - progress);
        sprite.color.set_alpha(alpha);

        if fade.0.just_finished() {
            commands.entity(entity).despawn();
        }
    }
}

// Handle key input and send events.
fn handle_keys(keyboard: Res<ButtonInput<KeyCode>>, mut input_events: MessageWriter<InputEvent>) {
    // Check for key presses.
    if keyboard.just_pressed(KeyCode::ArrowLeft) {
        input_events.write(InputEvent {
            direction: Some(Direction::Left),
            ..default()
        });
    } else if keyboard.just_pressed(KeyCode::ArrowRight) {
        input_events.write(InputEvent {
            direction: Some(Direction::Right),
            ..default()
        });
    } else if keyboard.just_pressed(KeyCode::ArrowUp) {
        input_events.write(InputEvent {
            direction: Some(Direction::Up),
            ..default()
        });
    }

    // Check for final key releases.
    if keyboard.just_released(KeyCode::ArrowLeft) && !keyboard.any_pressed(vec![KeyCode::ArrowLeft, KeyCode::ArrowUp]) {
        input_events.write(InputEvent::default());
    }
    if keyboard.just_released(KeyCode::ArrowRight) && !keyboard.any_pressed(vec![KeyCode::ArrowLeft, KeyCode::ArrowUp])
    {
        input_events.write(InputEvent::default());
    }
    if keyboard.just_released(KeyCode::ArrowUp) && !keyboard.any_pressed(vec![KeyCode::ArrowLeft, KeyCode::ArrowRight])
    {
        input_events.write(InputEvent::default());
    }
}

// Handle mouse input and send events.
fn handle_mouse_input(
    mut commands: Commands,
    mouse_input: Res<ButtonInput<MouseButton>>,
    windows: Query<&Window>,
    camera_query: Query<(&Camera, &GlobalTransform), With<Camera2d>>,
    interactables: Query<(&GlobalTransform, &Interactable)>,
    mut input_events: MessageWriter<InputEvent>,
) {
    if mouse_input.just_pressed(MouseButton::Left) {
        // Convert cursor position to world coordinates.
        let Ok(window) = windows.single() else {
            return;
        };
        let Some(cursor_pos): Option<Vec2> = window.cursor_position() else {
            return;
        };
        let Ok((camera, camera_transform)) = camera_query.single() else {
            return;
        };
        let Ok(world_pos) = camera.viewport_to_world_2d(camera_transform, cursor_pos) else {
            return;
        };

        process_world_click(&mut commands, world_pos, &interactables, &mut input_events);
    }
}

// Handle touch input and send events.
fn handle_touch_input(
    mut commands: Commands,
    touches: Res<Touches>,
    windows: Query<&Window>,
    camera_query: Query<(&Camera, &GlobalTransform), With<Camera2d>>,
    interactables: Query<(&GlobalTransform, &Interactable)>,
    mut input_events: MessageWriter<InputEvent>,
) {
    for touch in touches.iter_just_pressed() {
        // Convert touch position to world coordinates.
        let Ok(_window) = windows.single() else {
            continue;
        };
        let touch_pos = touch.position();
        let Ok((camera, camera_transform)) = camera_query.single() else {
            continue;
        };
        let Ok(world_pos) = camera.viewport_to_world_2d(camera_transform, touch_pos) else {
            continue;
        };

        process_world_click(&mut commands, world_pos, &interactables, &mut input_events);
    }
}

// Update the input world positions.
fn update_input_positions(
    mut inputs: ResMut<InputWorldPositions>,
    touches: Res<Touches>,
    windows: Query<&Window>,
    camera_query: Query<(&Camera, &GlobalTransform), With<Camera2d>>,
) {
    inputs.positions.clear();

    let Ok(window) = windows.single() else {
        return;
    };
    let Ok((camera, camera_transform)) = camera_query.single() else {
        return;
    };

    // Add cursor position if present.
    if let Some(cursor_pos) = window.cursor_position()
        && let Ok(world_pos) = camera.viewport_to_world_2d(camera_transform, cursor_pos)
    {
        inputs.positions.push(world_pos);
    }

    // Add all active touch positions.
    for touch in touches.iter() {
        let touch_pos = touch.position();
        if let Ok(world_pos) = camera.viewport_to_world_2d(camera_transform, touch_pos) {
            inputs.positions.push(world_pos);
        }
    }
}

// Detect overlap with interactable entities from any input and add or remove a Highlight component.
fn detect_hover(
    time: Res<Time>,
    mut commands: Commands,
    inputs: Res<InputWorldPositions>,
    interactables: Query<(Entity, &GlobalTransform, &Interactable)>,
    highlighted: Query<&Highlight>,
) {
    for (entity, transform, interactable) in &interactables {
        let overlapping = inputs.positions.iter().any(|&input_pos| {
            aabb_overlap(
                input_pos,
                CURSOR_SIZE,
                CURSOR_SIZE,
                transform.translation().truncate(),
                interactable.width,
                interactable.height,
            )
        });

        let currently_highlighted = highlighted.contains(entity);

        match (currently_highlighted, overlapping) {
            // New hover - add highlight if conditions met.
            (false, true) => {
                commands.entity(entity).insert(Highlight {
                    elapsed_offset: time.elapsed_secs(),
                });
            }

            // Hover ended - remove highlight.
            (true, false) => {
                commands.entity(entity).remove::<Highlight>();
            }
            _ => {}
        }
    }
}
